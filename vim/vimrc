if !exists('$LANG') && &encoding ==# 'latin1'
  set encoding=utf-8
endif
scriptencoding utf-8
function! s:OptionSplit(string) abort
  return map(
        \ split(&runtimepath, '\\\@<!,[, ]*'),
        \ 'substitute(v:val, ''\\,'', '','', ''g'')',
        \)
endfunction
function! s:EscItemExec(string) abort
  return escape(escape(
        \ a:string,
        \ ','), '\ %#|"')
endfunction
if exists('$MYVIM')
  execute 'set runtimepath^='.s:EscItemExec($MYVIM)
else
  let s:runtimepath = s:OptionSplit(&runtimepath)
  let $MYVIM = s:runtimepath[0]
endif
let s:cache = $MYVIM.'/cache'
if !isdirectory(s:cache)
  call mkdir(s:cache, 'p', 0700)
endif
let &viminfo .= ',n'.s:cache.'/viminfo'
set backup
let s:backupdir = s:cache.'/backup'
if !isdirectory(s:backupdir)
  call mkdir(s:backupdir, 'p', 0700)
endif
execute 'set backupdir^='.s:EscItemExec(
      \ s:backupdir.(has('patch-8.1.251') ? '//' : ''),
      \)
if has('unix')
  if !has('patch-8.1.1519')
    set backupskip&
  endif
  set backupskip^=/dev/shm/*,/usr/tmp/*,/var/tmp/*
endif
let s:directory = s:cache.'/swap'
if !isdirectory(s:directory)
  call mkdir(s:directory, 'p', 0700)
endif
execute 'set directory^='.s:EscItemExec(s:directory)
if has('persistent_undo')
  set undofile
  let s:undodir = s:cache.'/undo'
  if !isdirectory(s:undodir)
    call mkdir(s:undodir, 'p', 0700)
  endif
  execute 'set undodir^='.s:EscItemExec(s:undodir)
endif
filetype plugin indent on
function! s:ReloadFileType() abort
  if exists('g:did_load_filetypes')
    doautocmd filetypedetect BufRead
  endif
endfunction
command! -bar ReloadFileType
      \ call s:ReloadFileType()
function! s:ReloadVimrc() abort
  ReloadFileType
  redraw
  echomsg fnamemodify($MYVIMRC, ':p:~').' reloaded'
endfunction
command! -bar ReloadVimrc
      \ noautocmd source $MYVIMRC | call s:ReloadVimrc()
augroup vimrc
  autocmd!
augroup END
autocmd vimrc BufWritePost $MYVIMRC,$MYVIM/vimrc
      \ ReloadVimrc
if exists('##SourceCmd')
  autocmd vimrc SourceCmd $MYVIMRC,$MYVIM/vimrc
        \ ReloadVimrc
endif
set history=10000
set spelllang=en_nz
let s:spellfile = s:cache.'/spell/'.join([
      \ split(&spelllang, '_')[0],
      \ &encoding,
      \ 'add',
      \], '.')
execute 'set spellfile='.s:EscItemExec(s:spellfile)
let &spellcapcheck = '[.?!]\%(  \|[\n\r\t]\)'
set dictionary^=/usr/share/dict/words
let s:ref = $MYVIM.'/ref'
let s:dictionary = s:ref.'/dictionary.txt'
execute 'set dictionary^='.s:EscItemExec(s:dictionary)
let s:thesaurus = s:ref.'/thesaurus.txt'
execute 'set thesaurus^='.s:EscItemExec(s:thesaurus)
set comments= commentstring= define= include=
set path-=/usr/include
set autoindent
set expandtab
set shiftwidth=4
set smarttab
if v:version > 703 || v:version == 703 && has('patch693')
  set softtabstop=-1
else
  let &softtabstop = &shiftwidth
endif
set backspace+=eol
set backspace+=indent
set backspace+=start
set linebreak
if has('multi_byte_encoding')
  set showbreak=…
else
  set showbreak=...
endif
if exists('+breakindent')
  set breakindent
endif
set confirm
set noesckeys
set formatoptions+=l
set formatoptions+=1
if v:version > 703 || v:version == 703 && has('patch541')
  set formatoptions+=j
endif
set cpoptions+=J
if has('patch-8.1.728')
  set formatoptions+=p
endif
if has('gui_running')
  set guioptions+=M
endif
set hidden
set hlsearch
nohlsearch
set incsearch
set lazyredraw
set listchars+=tab:>-
set listchars+=trail:-
set listchars+=nbsp:+
if has('multi_byte_encoding')
  set listchars+=extends:»,precedes:«
else
  set listchars+=extends:>,precedes:<
endif
set nomodeline
set nrformats-=octal
set noruler
set sessionoptions-=localoptions
set sessionoptions-=options
set noshowcmd
set shortmess+=I
if !&loadplugins || globpath(&runtimepath, 'plugin/matchparen.vim') ==# ''
  set showmatch matchtime=3
endif
set splitbelow splitright
set synmaxcol=500
if &term =~# '^putty\|^tmux'
  set ttyfast
endif
set ttymouse=
set virtualedit+=block
set visualbell t_vb=
set wildmenu
set wildmode=list:longest,full
set wildignore=*~,#*#
      \,*.7z
      \,.DS_Store
      \,.git
      \,.hg
      \,.svn
      \,*.a
      \,*.adf
      \,*.asc
      \,*.au
      \,*.aup
      \,*.avi
      \,*.bin
      \,*.bmp
      \,*.bz2
      \,*.class
      \,*.db
      \,*.dbm
      \,*.djvu
      \,*.docx
      \,*.exe
      \,*.filepart
      \,*.flac
      \,*.gd2
      \,*.gif
      \,*.gifv
      \,*.gmo
      \,*.gpg
      \,*.gz
      \,*.hdf
      \,*.ico
      \,*.iso
      \,*.jar
      \,*.jpeg
      \,*.jpg
      \,*.m4a
      \,*.mid
      \,*.mp3
      \,*.mp4
      \,*.o
      \,*.odp
      \,*.ods
      \,*.odt
      \,*.ogg
      \,*.ogv
      \,*.opus
      \,*.pbm
      \,*.pdf
      \,*.png
      \,*.ppt
      \,*.psd
      \,*.pyc
      \,*.rar
      \,*.rm
      \,*.s3m
      \,*.sdbm
      \,*.sqlite
      \,*.swf
      \,*.swp
      \,*.tar
      \,*.tga
      \,*.ttf
      \,*.wav
      \,*.webm
      \,*.xbm
      \,*.xcf
      \,*.xls
      \,*.xlsx
      \,*.xpm
      \,*.xz
      \,*.zip
if exists('+wildignorecase')
  set wildignorecase
endif
if !exists('syntax_on')
  syntax enable
endif
autocmd vimrc ColorScheme *
      \ let &cursorline = g:colors_name ==# 'sahara'
if !exists('$COLORFGBG') && get(v:, 'termrbgresp', '') ==# ''
  set background=dark
endif
if &background ==# 'dark'
      \ && (has('gui_running') || &t_Co >= 256)
      \ && globpath(&runtimepath, 'colors/sahara.vim') !=# ''
  colorscheme sahara
endif
nnoremap <Backspace> <C-^>
nnoremap <expr> <Space>
      \ line('w$') < line('$')
      \ ? "\<PageDown>"
      \ : ":\<C-U>next\<CR>"
if &loadplugins && globpath(&runtimepath, 'plugin/insert_cancel.vim') !=# ''
  imap <C-C> <Plug>(InsertCancel)
endif
imap <C-K><C-K> <Plug>(DigraphSearch)
nnoremap <C-L>
      \ :<C-U>nohlsearch<CR><C-L>
inoremap <C-L> <C-O>:execute "normal \<C-L>"<CR>
vmap <C-L> <Esc><C-L>gv
nnoremap &
      \ :&&<CR>
xnoremap &
      \ :&&<CR>
nmap g: <Plug>(ColonOperator)
nnoremap [a
      \ :previous<CR>
nnoremap ]a
      \ :next<CR>
nnoremap [b
      \ :bprevious<CR>
nnoremap ]b
      \ :bnext<CR>
nnoremap [c
      \ :cprevious<CR>
nnoremap ]c
      \ :cnext<CR>
nnoremap [l
      \ :lprevious<CR>
nnoremap ]l
      \ :lnext<CR>
nmap [<Space> <Plug>(PutBlankLinesAbove)
nmap ]<Space> <Plug>(PutBlankLinesBelow)
let mapleader = '\'
let maplocalleader = ','
if maplocalleader ==# ','
  noremap ,, ,
  sunmap ,,
endif
nnoremap <Leader><Tab>
      \ :<C-U>set autoindent! autoindent?<CR>
nnoremap <Leader>c
      \ :<C-U>set cursorline! cursorline?<CR>
nnoremap <Leader>h
      \ :<C-U>set hlsearch! hlsearch?<CR>
nnoremap <Leader>i
      \ :<C-U>set incsearch! incsearch?<CR>
nnoremap <Leader>s
      \ :<C-U>set spell! spell?<CR>
nnoremap <Leader>C
      \ :<C-U>set cursorcolumn! cursorcolumn?<CR>
xmap <Leader>C <Esc><Leader>Cgv
nnoremap <Leader>l
      \ :<C-U>set list! list?<CR>
xmap <Leader>l <Esc><Leader>lgv
nnoremap <Leader>n
      \ :<C-U>set number! number?<CR>
xmap <Leader>n <Esc><Leader>ngv
nnoremap <Leader>N
      \ :<C-U>set ruler! ruler?<CR>
xmap <Leader>N <Esc><Leader>Ngv
nnoremap <Leader>w
      \ :<C-U>set wrap! wrap?<CR>
xmap <Leader>w <Esc><Leader>wgv
nnoremap <Leader>f
      \ :<C-U>set formatoptions?<CR>
nnoremap <Leader>u
      \ :<C-U>set spelllang=en_us<CR>
nnoremap <Leader>z
      \ :<C-U>set spelllang=en_nz<CR>
nmap <Leader>b <Plug>(CopyLinebreakToggle)
nnoremap <Leader>a
      \ :<C-U>ToggleFlagLocal formatoptions a<CR>
nnoremap <Leader>L
      \ :<C-U>ToggleFlagLocal colorcolumn +1<CR>
xmap <Leader>L <Esc><Leader>Lgv
nmap <Leader>p <Plug>PasteInsert
nnoremap <Leader>F
      \ :<C-U>ReloadFileType<CR>
nnoremap <Leader>t
      \ :<C-U>set filetype?<CR>
nnoremap <Leader>T
      \ :<C-U>set filetype=<CR>
nnoremap <Leader>d
      \ :PutDate<CR>
nnoremap <Leader>D
      \ :PutDate!<CR>
nnoremap <Leader>g
      \ :<C-U>echo expand('%:p')<CR>
nnoremap <Leader>G
      \ :<C-U>cd %:h<Bar>pwd<CR>
nnoremap <Leader>P
      \ :<C-U>Establish %:h<CR>
nnoremap <Leader>H
      \ :<C-U>history :<CR>
nnoremap <Leader>k
      \ :<C-U>marks<CR>
nnoremap <Leader>K
      \ :<C-U>function<CR>
nnoremap <Leader>m
      \ :<C-U>nmap<CR>
nnoremap <Leader>M
      \ :<C-U>nmap <buffer><CR>
nnoremap <Leader>S
      \ :<C-U>scriptnames<CR>
nnoremap <Leader>U
      \ :<C-U>command<CR>
nnoremap <Leader>v
      \ :<C-U>let g: v:<CR>
nnoremap <Leader>V
      \ :<C-U>let b: t: w:<CR>
nnoremap <Leader>y
      \ :<C-U>registers<CR>
nnoremap <Leader><Delete>
      \ :bdelete<CR>
nnoremap <Leader><Insert>
      \ :<C-U>enew<CR>
nnoremap <Leader>e
      \ :<C-U>set modifiable noreadonly<CR>
nnoremap <Leader>E
      \ :<C-U>set nomodifiable readonly<CR>
nnoremap <Leader>j
      \ :<C-U>buffers<CR>:buffer<Space>
nmap <Leader>o <Plug>(SelectOldFiles)
nnoremap <Leader>x
      \ :StripTrailingWhitespace<CR>
xnoremap <Leader>x
      \ :StripTrailingWhitespace<CR>
nnoremap <Leader>X
      \ :SqueezeRepeatBlanks<CR>
xnoremap <Leader>X
      \ :SqueezeRepeatBlanks<CR>
nnoremap <Leader>=
      \ :<C-U>KeepPosition execute 'normal! 1G=G'<CR>
nnoremap <Leader>+
      \ :<C-U>KeepPosition execute 'normal! 1GgqG'<CR>
onoremap <Leader>_
      \ :<C-U>execute 'normal! `[v`]'<CR>
onoremap <Leader>%
      \ :<C-U>execute 'normal! 1GVG'<CR>
omap <Leader>5 <Leader>%
map <Leader>{ <Plug>(VerticalRegionUp)
sunmap <Leader>{
map <Leader>} <Plug>(VerticalRegionDown)
sunmap <Leader>}
noremap <Leader>\ `"
sunmap <Leader>\
nnoremap <Leader><lt>
      \ :<C-U>'[,']<lt><CR>
nnoremap <Leader>>
      \ :<C-U>'[,']><CR>
nnoremap <Leader>/
      \ :<C-U>vimgrep /\c/j **<S-Left><S-Left><Right>
nnoremap <Leader>?
      \ :<C-U>lhelpgrep \c<S-Left>
nnoremap <Leader>.
      \ :<C-U>lmake!<CR>
nnoremap <Leader>q gqap
nmap <Leader>r <Plug>(ReplaceOperator)
xmap <Leader>r <Plug>(ReplaceOperator)
nnoremap <Leader>!
      \ :<Up><Home><S-Right>!<CR>
nmap <Leader>1 <Leader>!
nmap <Leader># <Plug>(AlternateFileType)
nmap <Leader>3 <Leader>#
nmap <Leader>$ <Plug>(Fortune)
nmap <Leader>4 <Leader>$
nmap <Leader>& <Plug>(RegexEscape)
nmap <Leader>7 <Leader>&
xmap <Leader>& <Plug>(RegexEscape)
xmap <Leader>7 <Leader>&
nnoremap <silent> <Leader>* *N
nmap <Leader>8 <Leader>*
nnoremap <silent> <Leader>`
      \ :<C-U>ScratchBuffer<CR>
nnoremap <silent> <Leader>~
      \ :<C-U>vertical ScratchBuffer<CR>
nnoremap <Leader>R
      \ :<C-U>ReloadVimrc<CR>
inoreabbrev tr@ tom@sanctum.geek.nz
inoreabbrev tr/ <https://sanctum.geek.nz/>
inoreabbrev almsot almost
inoreabbrev wrnog wrong
inoreabbrev Fielding Feilding
inoreabbrev THe The
inoreabbrev THere There
